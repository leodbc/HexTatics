<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#0d1117">
  <title>HexTatics</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>

  <!-- HUD Superior -->
  <div id="hud">
    <div id="hud-left">
      <span id="level-name">HexTatics</span>
      <span id="level-description"></span>
    </div>
    <div id="hud-center">
      <span id="move-counter">Movimentos: 0</span>
    </div>
    <div id="hud-right">
      <button class="btn" id="btn-rules" title="Regras">‚ùì <span class="btn-label">Regras</span></button>
      <button class="btn" id="btn-undo" title="Desfazer (Ctrl+Z)">‚Ü© <span class="btn-label">Desfazer</span></button>
      <button class="btn btn-danger" id="btn-reset" title="Reiniciar">üîÑ <span class="btn-label">Reiniciar</span></button>
      <button class="btn" id="btn-levels" title="Fases">üìã <span class="btn-label">Fases</span></button>
    </div>
  </div>

  <!-- √Årea principal -->
  <div id="main-area">
    <div id="canvas-container">
      <canvas id="gameCanvas"></canvas>
    </div>
    <div id="hand-panel">
      <div id="hand-title">M√£o</div>
      <div id="hand-pieces"></div>
    </div>
  </div>

  <!-- Controles mobile (vis√≠veis apenas em telas pequenas) -->
  <div id="mobile-controls">
    <button class="btn" id="mb-rules">‚ùì Regras</button>
    <button class="btn" id="mb-undo">‚Ü© Desfazer</button>
    <button class="btn btn-danger" id="mb-reset">üîÑ Reiniciar</button>
    <button class="btn" id="mb-levels">üìã Fases</button>
  </div>

  <!-- Overlay de mensagens -->
  <div id="overlay">
    <div id="overlay-content">
      <div id="overlay-stars"></div>
      <div id="overlay-title"></div>
      <div id="overlay-message"></div>
      <div id="overlay-buttons"></div>
    </div>
  </div>

  <!-- Modal de sele√ß√£o de fases -->
  <div id="level-select-modal">
    <div id="level-select-content">
      <h2>üéØ Selecionar Fase</h2>
      <div id="level-list" class="level-grid"></div>
      <button class="btn" id="close-level-select">Fechar</button>
    </div>
  </div>

  <!-- Tooltip de regras -->
  <div id="rules-tooltip">
    <h4>üìñ Regras das Pe√ßas</h4>
    <div class="rule-item red">
      <strong>Vermelha (R):</strong> Remover se tiver 1+ vizinhos, mas N√ÉO todos.
    </div>
    <div class="rule-item blue">
      <strong>Azul (B):</strong> Remover se N√ÉO tiver nenhum vizinho.
    </div>
    <div class="rule-item green">
      <strong>Verde (G):</strong> Remover se TODOS os vizinhos estiverem preenchidos.
    </div>
    <div class="rule-item yellow">
      <strong>Amarela (Y):</strong> Exatamente 3 vizinhos, sem pares opostos.
    </div>
    <div class="rule-item gray">
      <strong>Cinza (‚ñ™):</strong> Remov√≠vel somente quando for a √∫ltima pe√ßa.
    </div>
    <div class="rules-modifier-note">
      ‚≠ï C√≠rculo colorido = modificador: considera apenas pe√ßas DAQUELA cor como vizinhas.
    </div>
  </div>

  <!-- Toast container -->
  <div id="toast-container"></div>

  <!-- Scripts -->
  <script src="levels.js"></script>
  <script src="game.js"></script>
  <script src="renderer.js"></script>
  <script src="solver.js"></script>

  <script>
    // ==========================================
    // INICIALIZA√á√ÉO
    // ==========================================

    const canvas = document.getElementById('gameCanvas');
    const levelNameEl = document.getElementById('level-name');
    const levelDescEl = document.getElementById('level-description');
    const moveCounterEl = document.getElementById('move-counter');
    const handPiecesEl = document.getElementById('hand-pieces');
    const handPanel = document.getElementById('hand-panel');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlay-title');
    const overlayMessage = document.getElementById('overlay-message');
    const overlayButtons = document.getElementById('overlay-buttons');
    const overlayStars = document.getElementById('overlay-stars');
    const levelSelectModal = document.getElementById('level-select-modal');
    const levelListEl = document.getElementById('level-list');
    const rulesTooltip = document.getElementById('rules-tooltip');

    const game = new Game();
    const renderer = new Renderer(canvas, game);
    game.onStateChange = updateUI;

    // Progress tracking
    const completedLevels = new Set();
    const levelBestMoves = {};

    function loadProgress() {
      try {
        const saved = localStorage.getItem('hextatics_progress');
        if (saved) {
          const data = JSON.parse(saved);
          if (data.completed) data.completed.forEach(id => completedLevels.add(id));
          if (data.bestMoves) Object.assign(levelBestMoves, data.bestMoves);
        }
      } catch(e) {}
    }

    function saveProgress() {
      try {
        localStorage.setItem('hextatics_progress', JSON.stringify({
          completed: [...completedLevels],
          bestMoves: levelBestMoves
        }));
      } catch(e) {}
    }

    loadProgress();

    // ==========================================
    // CARREGAR FASE
    // ==========================================

    function loadLevel(levelId) {
      const level = LEVELS.find(l => l.id === levelId);
      if (!level) return;

      game.loadLevel(level);
      renderer.resize();
      hideOverlay();
      hideLevelSelect();
      updateUI();
    }

    // ==========================================
    // ATUALIZAR INTERFACE
    // ==========================================

    function updateUI() {
      if (game.currentLevel) {
        levelNameEl.textContent = `Fase ${game.currentLevel.id}: ${game.currentLevel.name}`;
        levelDescEl.textContent = game.currentLevel.description;
      }

      if (game.moveLimit) {
        moveCounterEl.textContent = `${game.moves} / ${game.moveLimit}`;
        moveCounterEl.classList.toggle('over-limit', game.moves >= game.moveLimit);
      } else {
        moveCounterEl.textContent = `${game.moves} mov.`;
        moveCounterEl.classList.remove('over-limit');
      }

      updateHand();

      if (game.state === 'won') {
        // Save progress
        if (game.currentLevel) {
          const id = game.currentLevel.id;
          completedLevels.add(id);
          if (!levelBestMoves[id] || game.moves < levelBestMoves[id]) {
            levelBestMoves[id] = game.moves;
          }
          saveProgress();
        }
        showWinOverlay();
      } else if (game.state === 'lost') {
        showLoseOverlay();
      }
    }

    function updateHand() {
      handPiecesEl.innerHTML = '';

      const colorMap = {
        red: '#e5534b', blue: '#388bfd', green: '#3fb950',
        yellow: '#d29922', gray: '#6e7681'
      };

      const symbolMap = {
        red: 'R', blue: 'B', green: 'G', yellow: 'Y', gray: '‚ñ™'
      };

      if (game.hand.length === 0) {
        const emptyMsg = document.createElement('div');
        emptyMsg.className = 'hand-empty';
        emptyMsg.textContent = 'Vazia';
        handPiecesEl.appendChild(emptyMsg);
        handPanel.classList.remove('has-pieces');
      } else {
        handPanel.classList.add('has-pieces');
      }

      game.hand.forEach((piece, index) => {
        const div = document.createElement('div');
        div.className = `hand-piece ${piece.color}`;
        div.textContent = symbolMap[piece.color] || '?';

        if (game.selectedHandPiece === index) {
          div.classList.add('selected');
        }

        if (piece.modifier) {
          const dot = document.createElement('div');
          dot.className = 'modifier-dot';
          dot.style.backgroundColor = colorMap[piece.modifier] || '#888';
          div.appendChild(dot);
        }

        div.addEventListener('click', (e) => {
          e.stopPropagation();
          if (game.selectedHandPiece === index) {
            game.deselectHandPiece();
          } else {
            game.selectHandPiece(index);
          }
        });

        // Touch support for hand pieces
        div.addEventListener('touchend', (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (game.selectedHandPiece === index) {
            game.deselectHandPiece();
          } else {
            game.selectHandPiece(index);
          }
        });

        handPiecesEl.appendChild(div);
      });
    }

    // ==========================================
    // TOAST MESSAGES
    // ==========================================

    function showToast(message, isError = false) {
      const container = document.getElementById('toast-container');
      const toast = document.createElement('div');
      toast.className = `toast${isError ? ' error' : ''}`;
      toast.textContent = message;
      container.innerHTML = '';
      container.appendChild(toast);
      setTimeout(() => { toast.remove(); }, 2500);
    }

    // ==========================================
    // OVERLAYS
    // ==========================================

    function showWinOverlay() {
      const moves = game.moves;
      const pieces = game.currentLevel.pieces.length;

      // Star rating based on efficiency
      let stars = '‚≠ê';
      if (moves <= pieces + 2) stars = '‚≠ê‚≠ê‚≠ê';
      else if (moves <= pieces + 5) stars = '‚≠ê‚≠ê';

      overlayStars.textContent = stars;
      overlayTitle.textContent = 'üéâ Parab√©ns!';
      overlayTitle.className = 'win';
      overlayMessage.textContent = `Puzzle resolvido em ${moves} movimentos!`;

      overlayButtons.innerHTML = '';

      const currentIdx = LEVELS.findIndex(l => l.id === game.currentLevel.id);
      if (currentIdx < LEVELS.length - 1) {
        const nextBtn = document.createElement('button');
        nextBtn.className = 'btn btn-primary';
        nextBtn.textContent = '‚ñ∂ Pr√≥xima Fase';
        nextBtn.addEventListener('click', () => loadLevel(LEVELS[currentIdx + 1].id));
        overlayButtons.appendChild(nextBtn);
      }

      const replayBtn = document.createElement('button');
      replayBtn.className = 'btn';
      replayBtn.textContent = 'üîÑ Jogar Novamente';
      replayBtn.addEventListener('click', () => { game.reset(); hideOverlay(); });
      overlayButtons.appendChild(replayBtn);

      const levelsBtn = document.createElement('button');
      levelsBtn.className = 'btn';
      levelsBtn.textContent = 'üìã Fases';
      levelsBtn.addEventListener('click', () => { hideOverlay(); showLevelSelect(); });
      overlayButtons.appendChild(levelsBtn);

      overlay.classList.add('visible');
    }

    function showLoseOverlay() {
      overlayStars.textContent = '';
      overlayTitle.textContent = '‚ùå Limite Excedido!';
      overlayTitle.className = 'lose';
      overlayMessage.textContent = 'Voc√™ excedeu o limite de movimentos.';

      overlayButtons.innerHTML = '';

      const undoBtn = document.createElement('button');
      undoBtn.className = 'btn';
      undoBtn.textContent = '‚Ü© Desfazer √öltimo';
      undoBtn.addEventListener('click', () => { game.undo(); hideOverlay(); });
      overlayButtons.appendChild(undoBtn);

      const resetBtn = document.createElement('button');
      resetBtn.className = 'btn btn-danger';
      resetBtn.textContent = 'üîÑ Reiniciar';
      resetBtn.addEventListener('click', () => { game.reset(); hideOverlay(); });
      overlayButtons.appendChild(resetBtn);

      overlay.classList.add('visible');
    }

    function hideOverlay() {
      overlay.classList.remove('visible');
    }

    // ==========================================
    // SELE√á√ÉO DE FASES
    // ==========================================

    function showLevelSelect() {
      levelListEl.innerHTML = '';

      for (const level of LEVELS) {
        const card = document.createElement('div');
        card.className = 'level-card';

        if (completedLevels.has(level.id)) card.classList.add('completed');
        if (game.currentLevel && game.currentLevel.id === level.id) card.classList.add('current');

        const numberEl = document.createElement('div');
        numberEl.className = 'level-card-number';
        numberEl.textContent = completedLevels.has(level.id) ? '‚úì' : level.id;

        const infoEl = document.createElement('div');
        infoEl.className = 'level-card-info';

        const titleEl = document.createElement('h3');
        titleEl.textContent = level.name;

        const descEl = document.createElement('p');
        descEl.textContent = level.description;

        infoEl.appendChild(titleEl);
        infoEl.appendChild(descEl);

        const metaEl = document.createElement('div');
        metaEl.className = 'level-card-meta';
        let metaText = `${level.pieces.length} pe√ßas`;
        if (level.moveLimit) metaText += ` ¬∑ ${level.moveLimit} mov.`;
        if (levelBestMoves[level.id]) metaText += ` ¬∑ ‚≠ê${levelBestMoves[level.id]}`;
        metaEl.textContent = metaText;

        card.appendChild(numberEl);
        card.appendChild(infoEl);
        card.appendChild(metaEl);

        card.addEventListener('click', () => loadLevel(level.id));
        levelListEl.appendChild(card);
      }

      levelSelectModal.classList.add('visible');
    }

    function hideLevelSelect() {
      levelSelectModal.classList.remove('visible');
    }

    // ==========================================
    // TOOLTIP DE REGRAS
    // ==========================================

    let rulesVisible = false;

    function toggleRules() {
      rulesVisible = !rulesVisible;
      if (rulesVisible) {
        // Position tooltip
        const isMobile = window.innerWidth <= 480;
        if (!isMobile) {
          const btn = document.getElementById('btn-rules');
          const rect = btn.getBoundingClientRect();
          rulesTooltip.style.top = (rect.bottom + 8) + 'px';
          rulesTooltip.style.right = '16px';
          rulesTooltip.style.left = 'auto';
          rulesTooltip.style.bottom = 'auto';
        }
        rulesTooltip.classList.add('visible');
      } else {
        rulesTooltip.classList.remove('visible');
      }
    }

    // ==========================================
    // CANVAS ‚Äî Mouse Events
    // ==========================================

    canvas.addEventListener('mousemove', (e) => {
      const { x, y } = renderer.getCanvasCoords(e.clientX, e.clientY);
      renderer.updateHover(x, y);

      const hex = renderer.hoverHex;
      if (hex) {
        const piece = game.getPiece(hex.q, hex.r);
        if (piece && game.selectedHandPiece === null) {
          canvas.style.cursor = game.canRemove(hex.q, hex.r) ? 'pointer' : 'not-allowed';
        } else if (!piece && game.selectedHandPiece !== null && game.canPlaceAt(hex.q, hex.r)) {
          canvas.style.cursor = 'pointer';
        } else {
          canvas.style.cursor = 'default';
        }
      } else {
        canvas.style.cursor = 'default';
      }
    });

    canvas.addEventListener('mouseleave', () => {
      renderer.clearHover();
      canvas.style.cursor = 'default';
    });

    canvas.addEventListener('click', (e) => {
      handleCanvasInteraction(e.clientX, e.clientY);
    });

    // ==========================================
    // CANVAS ‚Äî Touch Events
    // ==========================================

    let touchStartTime = 0;
    let touchMoved = false;

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      touchStartTime = Date.now();
      touchMoved = false;
      const touch = e.touches[0];
      const { x, y } = renderer.getCanvasCoords(touch.clientX, touch.clientY);
      renderer.updateHover(x, y);
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      touchMoved = true;
      const touch = e.touches[0];
      const { x, y } = renderer.getCanvasCoords(touch.clientX, touch.clientY);
      renderer.updateHover(x, y);
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      if (!touchMoved && Date.now() - touchStartTime < 500) {
        const touch = e.changedTouches[0];
        handleCanvasInteraction(touch.clientX, touch.clientY);
      }
      // Delay clearing hover so the user sees feedback
      setTimeout(() => renderer.clearHover(), 150);
    }, { passive: false });

    canvas.addEventListener('touchcancel', (e) => {
      renderer.clearHover();
    });

    // ==========================================
    // INTERA√á√ÉO UNIFICADA (mouse + touch)
    // ==========================================

    function handleCanvasInteraction(clientX, clientY) {
      if (game.state !== 'playing') return;

      const { x, y } = renderer.getCanvasCoords(clientX, clientY);
      const hex = renderer.pixelToHex(x, y);

      if (!hex) {
        game.deselectHandPiece();
        return;
      }

      const piece = game.getPiece(hex.q, hex.r);

      if (game.selectedHandPiece !== null) {
        if (!piece && game.canPlaceAt(hex.q, hex.r)) {
          const handIndex = game.selectedHandPiece;
          renderer.addFadeIn(hex.q, hex.r);
          game.placePiece(hex.q, hex.r, handIndex);
          game.deselectHandPiece();
        } else if (piece) {
          game.deselectHandPiece();
          if (game.canRemove(hex.q, hex.r)) {
            renderer.addFadeOut(hex.q, hex.r, piece);
            game.removePiece(hex.q, hex.r);
          } else {
            showToast('Esta pe√ßa n√£o pode ser removida agora', true);
          }
        }
      } else {
        if (piece) {
          if (game.canRemove(hex.q, hex.r)) {
            renderer.addFadeOut(hex.q, hex.r, piece);
            game.removePiece(hex.q, hex.r);
          } else {
            showToast('Esta pe√ßa n√£o pode ser removida agora', true);
          }
        }
      }
    }

    // ==========================================
    // EVENTOS DOS BOT√ïES (Desktop)
    // ==========================================

    document.getElementById('btn-undo').addEventListener('click', () => { game.undo(); hideOverlay(); });
    document.getElementById('btn-reset').addEventListener('click', () => { game.reset(); hideOverlay(); });
    document.getElementById('btn-levels').addEventListener('click', () => showLevelSelect());
    document.getElementById('btn-rules').addEventListener('click', () => toggleRules());
    document.getElementById('close-level-select').addEventListener('click', () => hideLevelSelect());

    // EVENTOS DOS BOT√ïES (Mobile)
    document.getElementById('mb-undo').addEventListener('click', () => { game.undo(); hideOverlay(); });
    document.getElementById('mb-reset').addEventListener('click', () => { game.reset(); hideOverlay(); });
    document.getElementById('mb-levels').addEventListener('click', () => showLevelSelect());
    document.getElementById('mb-rules').addEventListener('click', () => toggleRules());

    // Fechar modais
    levelSelectModal.addEventListener('click', (e) => {
      if (e.target === levelSelectModal) hideLevelSelect();
    });

    overlay.addEventListener('click', (e) => {
      if (e.target === overlay) hideOverlay();
    });

    document.addEventListener('click', (e) => {
      if (rulesVisible && !rulesTooltip.contains(e.target) &&
          e.target.id !== 'btn-rules' && e.target.id !== 'mb-rules' &&
          !e.target.closest('#btn-rules') && !e.target.closest('#mb-rules')) {
        rulesVisible = false;
        rulesTooltip.classList.remove('visible');
      }
    });

    // ==========================================
    // TECLADO
    // ==========================================

    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.key === 'z') {
        e.preventDefault();
        game.undo();
        hideOverlay();
      }
      if (e.key === 'Escape') {
        game.deselectHandPiece();
        hideLevelSelect();
        hideOverlay();
        if (rulesVisible) { rulesVisible = false; rulesTooltip.classList.remove('visible'); }
      }
      if (e.key === 'r' && !e.ctrlKey && !e.metaKey) {
        game.reset();
        hideOverlay();
      }
    });

    // ==========================================
    // RESIZE
    // ==========================================

    let resizeTimer;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => renderer.resize(), 50);
    });

    // Prevent double-tap zoom on iOS
    let lastTouchEnd = 0;
    document.addEventListener('touchend', (e) => {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) e.preventDefault();
      lastTouchEnd = now;
    }, { passive: false });

    // ==========================================
    // INICIAR
    // ==========================================

    loadLevel(1);

    console.log('%cüéØ HexTatics', 'font-size: 20px; color: #3fb950;');
    console.log('Use solve(levelId) para resolver uma fase.');
  </script>

</body>
</html>
